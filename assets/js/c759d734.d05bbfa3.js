"use strict";(globalThis.webpackChunkbackend_docs=globalThis.webpackChunkbackend_docs||[]).push([[1633],{2852:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"copilot/copilot-edit-integration","title":"Copilot Edit Flow Documentation","description":"Section A: Edit API Reference","source":"@site/docs/copilot/copilot-edit-integration.md","sourceDirName":"copilot","slug":"/copilot/copilot-edit-integration","permalink":"/backend-docs/docs/copilot/copilot-edit-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/copilot/copilot-edit-integration.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"New Copilot Onboarding - Frontend Integration Guide","permalink":"/backend-docs/docs/copilot/new-copilot-integration"},"next":{"title":"Old Copilot Onboarding - Frontend Integration Guide","permalink":"/backend-docs/docs/copilot/copilot-integration"}}');var i=t(4848),a=t(8453);const o={sidebar_position:2},r="Copilot Edit Flow Documentation",d={},c=[{value:"Section A: Edit API Reference",id:"section-a-edit-api-reference",level:2},{value:"Edit Endpoint",id:"edit-endpoint",level:3},{value:"Edit Value Types by Substep",id:"edit-value-types-by-substep",level:3},{value:"Edit Response Patterns",id:"edit-response-patterns",level:3},{value:"Pattern 1: Inline Edit (Same Section, No Affected Substeps)",id:"pattern-1-inline-edit-same-section-no-affected-substeps",level:4},{value:"Pattern 2: Edit with Affected Substeps (Same Section)",id:"pattern-2-edit-with-affected-substeps-same-section",level:4},{value:"Pattern 3: Cross-Section Edit (Edit from Different Section)",id:"pattern-3-cross-section-edit-edit-from-different-section",level:4},{value:"Pattern 4: Edit Return (Completing Cross-Section Edit)",id:"pattern-4-edit-return-completing-cross-section-edit",level:4},{value:"Pattern 5: Edit Requiring Plan Upgrade",id:"pattern-5-edit-requiring-plan-upgrade",level:4},{value:"Pattern 6: Edit to Manual Setup Exit",id:"pattern-6-edit-to-manual-setup-exit",level:4},{value:"Edit-Specific Endpoints",id:"edit-specific-endpoints",level:3},{value:"Edit Logo (Multipart)",id:"edit-logo-multipart",level:4},{value:"Change Plan (Special Edit)",id:"change-plan-special-edit",level:4},{value:"Edit Validation Rules",id:"edit-validation-rules",level:3},{value:"Edit Error Responses",id:"edit-error-responses",level:3},{value:"Edit Context Lifecycle",id:"edit-context-lifecycle",level:2},{value:"Edit Context Structure",id:"edit-context-structure",level:3},{value:"When Edit Context Is Set",id:"when-edit-context-is-set",level:3},{value:"Edit Context State Transitions",id:"edit-context-state-transitions",level:3},{value:"Edit Context Clearing Triggers",id:"edit-context-clearing-triggers",level:3},{value:"Edit Impact Chains",id:"edit-impact-chains",level:2},{value:"Edit Impact Map",id:"edit-impact-map",level:3},{value:"Impact Chain Execution",id:"impact-chain-execution",level:3},{value:"Cascading Impact Example",id:"cascading-impact-example",level:3},{value:"Edit History Tracking",id:"edit-history-tracking",level:2},{value:"Edit History Structure",id:"edit-history-structure",level:3},{value:"When Edit History Is Recorded",id:"when-edit-history-is-recorded",level:3},{value:"Edit History Use Cases",id:"edit-history-use-cases",level:3},{value:"Return Flow Navigation",id:"return-flow-navigation",level:2},{value:"Return Flow Decision Tree",id:"return-flow-decision-tree",level:3},{value:"Return Flow Scenarios",id:"return-flow-scenarios",level:3},{value:"Scenario 1: Simple Return (All Affected Substeps in Same Section)",id:"scenario-1-simple-return-all-affected-substeps-in-same-section",level:4},{value:"Scenario 2: Multi-Section Return (Affected Substeps Span Sections)",id:"scenario-2-multi-section-return-affected-substeps-span-sections",level:4},{value:"Scenario 3: Return with Dynamic Rehydration",id:"scenario-3-return-with-dynamic-rehydration",level:4},{value:"Scenario 4: Return After Upgrade Flow",id:"scenario-4-return-after-upgrade-flow",level:4},{value:"Return Position Edge Cases",id:"return-position-edge-cases",level:3},{value:"Cleanup and Data Clearing Patterns",id:"cleanup-and-data-clearing-patterns",level:2},{value:"Field Clearing Strategies",id:"field-clearing-strategies",level:3},{value:"Substep Clearing Implementation",id:"substep-clearing-implementation",level:3},{value:"Channel Deletion During Edit",id:"channel-deletion-during-edit",level:3},{value:"Assistant Deletion During Edit",id:"assistant-deletion-during-edit",level:3},{value:"Draft Finalization Pattern",id:"draft-finalization-pattern",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"copilot-edit-flow-documentation",children:"Copilot Edit Flow Documentation"})}),"\n",(0,i.jsx)(n.h2,{id:"section-a-edit-api-reference",children:"Section A: Edit API Reference"}),"\n",(0,i.jsx)(n.h3,{id:"edit-endpoint",children:"Edit Endpoint"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'POST /copilot/edit/:substepId\n\nPath Parameter:\n  substepId: string  // ID of the substep to edit\n\nRequest Body: EditSubstepDto\n{\n  substepId: string,      // Must match path parameter (redundant but validated)\n  newValue: any           // Type varies by substep - see table below\n}\n\nResponse: CopilotResponseDto\n{\n  currentSubstep: {\n    id: string,\n    botMessage: [...],\n    options: [...]\n  } | null,\n  uiDirectives: {\n    isInEditFlow?: boolean,        // True if navigating to affected substeps\n    editComplete?: boolean,         // True if edit finished inline\n    returnedFromEdit?: boolean,     // True if returning from edit flow\n    exitToManualSetup?: boolean,    // True if switching to manual config\n    editContext?: {                 // Present if isInEditFlow === true\n      editedSubstep: string,\n      editedSection: string,\n      affectedSubsteps: Array<{\n        substep: string,\n        section: string\n      }>\n    },\n    components: [...]\n  },\n  lastUserMessage?: {\n    messageType: "USER_EDIT",\n    content: string,\n    metadata: {\n      section: string,\n      substep: string,\n      action: "edit",\n      formField: string,\n      previousValue: any\n    },\n    createdAt: string\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-value-types-by-substep",children:"Edit Value Types by Substep"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Text input substeps:\n{\n  businessName: {\n    newValue: string,              // Example: "New Business Name Ltd"\n    validation: "1-200 chars"\n  }\n}\n\n// Single choice substeps:\n{\n  businessIndustry: {\n    newValue: IndustryType,        // Example: "HEALTHCARE_CLINICS"\n    validation: "Must be valid IndustryType enum"\n  },\n\n  selectBusinessNameMatch: {\n    newValue: BusinessMatch | "",  // Full object OR empty string for "not listed"\n    validation: "Must be from original search results or empty"\n  },\n\n  confirmChannelsConfiguration: {\n    newValue: boolean,             // true = recommended, false = manual\n    validation: "Must be boolean"\n  },\n\n  noReplyConfiguration: {\n    newValue: "escalate" | "followUp" | "none",\n    validation: "Must be one of three values"\n  },\n\n  aiAssistantsForChannels: {\n    newValue: "single" | "multiple",\n    validation: "Must be \'single\' or \'multiple\'"\n  }\n}\n\n// Multiple choice substeps:\n{\n  channels: {\n    newValue: string[],            // Example: ["whatsapp", "gmail", "slack"]\n    validation: "Array of valid channel values, length >= 1"\n  },\n\n  adjustGoalsObjectives: {\n    newValue: string[],            // Example: ["goal:1", "goal:3", "objective:2"]\n    validation: "Array of \'goal:id\' or \'objective:id\' or [\'keepCurrent\']"\n  }\n}\n\n// Range choice substeps:\n{\n  teamSize: {\n    newValue: "1" | "2-5" | "6-20" | "21",\n    validation: "Must be one of four size ranges"\n  }\n}\n\n// Special substeps:\n{\n  planConfirmation: {\n    // Handled via separate POST /copilot/change-plan endpoint\n    // Not editable via edit endpoint\n  },\n\n  businessLogo: {\n    // Handled via POST /copilot/edit-logo with multipart/form-data\n    // Not editable via JSON edit endpoint\n  }\n}\n\n// Multiple choice with sub-select:\n{\n  addAutomations: {\n    newValue: "yes" | "false",         // Parent selection\n    subSelectValues: string[],         // Required when newValue === "yes"\n    validation: "If \'yes\', subSelectValues must contain at least one automation type",\n    examples: [\n      {\n        // Skip automations\n        newValue: "false"\n      },\n      {\n        // Select specific automations\n        newValue: "yes",\n        subSelectValues: ["Tag new leads", "Follow-up after 24h"]\n      }\n    ]\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-response-patterns",children:"Edit Response Patterns"}),"\n",(0,i.jsx)(n.h4,{id:"pattern-1-inline-edit-same-section-no-affected-substeps",children:"Pattern 1: Inline Edit (Same Section, No Affected Substeps)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Request:\nPOST /copilot/edit/noReplyConfiguration\n{\n  substepId: "noReplyConfiguration",\n  newValue: "escalate"\n}\n\n// Response:\n{\n  currentSubstep: {\n    id: "confirmNoReplyConfiguration",  // Current substep (unchanged)\n    botMessage: [\n      {\n        type: "text",\n        message: "Updated fallback behavior to \\"escalate\\"."\n      },\n      {\n        type: "text",\n        message: "Great! When a customer doesn\'t reply..."  // Original bot message\n      }\n    ]\n  },\n  uiDirectives: {\n    editComplete: true,                 // \u2705 Edit finished\n    isInEditFlow: false,                // No navigation needed\n    components: [...]\n  },\n  lastUserMessage: {\n    messageType: "USER_EDIT",\n    content: "escalate",\n    metadata: {\n      section: "fallbackLogic",\n      substep: "noReplyConfiguration",\n      action: "edit",\n      formField: "noReplyConfiguration",\n      previousValue: "followUp"\n    },\n    createdAt: "2024-01-15T11:00:00Z"\n  }\n}\n\n// Frontend action:\n// - Display confirmation message\n// - Update collected_data locally\n// - Stay on current screen\n// - No navigation needed\n'})}),"\n",(0,i.jsx)(n.h4,{id:"pattern-2-edit-with-affected-substeps-same-section",children:"Pattern 2: Edit with Affected Substeps (Same Section)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Request:\nPOST /copilot/edit/businessIndustry\n{\n  substepId: "businessIndustry",\n  newValue: "HEALTHCARE_CLINICS"\n}\n\n// Response:\n{\n  currentSubstep: {\n    id: "confirmBusinessData",          // Navigated to affected substep\n    botMessage: [\n      {\n        type: "text",\n        message: "Updated industry to HEALTHCARE_CLINICS. I\'ve regenerated your business goals based on this industry."\n      },\n      {\n        type: "text",\n        message: "**Acme Electronics Inc.**\\n\\n\ud83c\udfaf Goals:\\n- Improve patient satisfaction..."\n      }\n    ]\n  },\n  uiDirectives: {\n    editComplete: true,                 // \u2705 Edit finished (same section)\n    isInEditFlow: false,                // Not cross-section\n    components: [\n      { name: "businessLogo", metadata: {...} }\n    ]\n  },\n  lastUserMessage: {\n    messageType: "USER_EDIT",\n    content: "HEALTHCARE_CLINICS",\n    metadata: {\n      section: "businessIdentity",\n      substep: "businessIndustry",\n      action: "edit",\n      formField: "industry",\n      previousValue: "ECOMMERCE_RETAIL"\n    },\n    createdAt: "2024-01-15T11:05:00Z"\n  }\n}\n\n// Backend actions performed:\n// 1. Updated industry in collected_data\n// 2. Cleared suggested_goals, suggested_objectives (affected data)\n// 3. Cleared confirmBusinessData, adjustGoalsObjectives (affected substeps)\n// 4. Regenerated goals via LLM using new industry\n// 5. Navigated to confirmBusinessData\n// 6. Added to edit_history\n\n// Frontend action:\n// - Navigate to confirmBusinessData substep\n// - Display updated goals\n// - User continues from here (can confirm or adjust again)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"pattern-3-cross-section-edit-edit-from-different-section",children:"Pattern 3: Cross-Section Edit (Edit from Different Section)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Current position: channels section, channels substep\n// User edits: businessIndustry (from businessIdentity section)\n\n// Request:\nPOST /copilot/edit/businessIndustry\n{\n  substepId: "businessIndustry",\n  newValue: "REAL_ESTATE"\n}\n\n// Response:\n{\n  currentSubstep: {\n    id: "confirmBusinessData",          // First affected substep\n    botMessage: [\n      {\n        type: "text",\n        message: "Updated industry to REAL_ESTATE. I\'ve regenerated your business goals based on this industry."\n      },\n      {\n        type: "text",\n        message: "**Acme Electronics Inc.**\\n\\n\ud83c\udfaf Goals:\\n- Close more property deals..."\n      }\n    ]\n  },\n  uiDirectives: {\n    isInEditFlow: true,                 // \u2705 Cross-section edit\n    editComplete: false,                // Not done yet\n    returnedFromEdit: false,\n    editContext: {\n      editedSubstep: "businessIndustry",\n      editedSection: "businessIdentity",\n      affectedSubsteps: [\n        { substep: "confirmBusinessData", section: "businessIdentity" },\n        { substep: "adjustGoalsObjectives", section: "businessIdentity" }\n      ]\n    },\n    components: [...]\n  },\n  lastUserMessage: {\n    messageType: "USER_EDIT",\n    content: "REAL_ESTATE",\n    metadata: {\n      section: "businessIdentity",\n      substep: "businessIndustry",\n      action: "edit",\n      formField: "industry",\n      previousValue: "ECOMMERCE_RETAIL"\n    },\n    createdAt: "2024-01-15T11:10:00Z"\n  }\n}\n\n// Backend actions performed:\n// 1. Detected cross-section edit (current: channels, editing: businessIdentity)\n// 2. Set edit_return_position = { section: "channels", substep: "channels" }\n// 3. Set is_in_edit_flow = true\n// 4. Cleared affected substeps and data\n// 5. Regenerated goals\n// 6. Navigated to first affected substep (confirmBusinessData)\n\n// Frontend action:\n// - Navigate to confirmBusinessData (different section!)\n// - Show edit context UI (e.g., "Editing business identity, will return to channels")\n// - User must complete affected substeps\n// - After completion, will return to original position\n'})}),"\n",(0,i.jsx)(n.h4,{id:"pattern-4-edit-return-completing-cross-section-edit",children:"Pattern 4: Edit Return (Completing Cross-Section Edit)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// User in edit flow (editing businessIndustry from channels section)\n// User completes confirmBusinessData\n\n// Request:\nPOST /copilot/message\n{\n  inputType: "selection",\n  content: "Confirm",\n  metadata: {\n    substepId: "confirmBusinessData",\n    selectedOption: "confirm"\n  }\n}\n\n// Response:\n{\n  currentSubstep: {\n    id: "channels",                     // \u2705 Returned to original position\n    botMessage: []                      // Empty - already displayed\n  },\n  uiDirectives: {\n    editComplete: true,                 // \u2705 Edit flow finished\n    returnedFromEdit: true,             // \u2705 Returned from edit\n    isInEditFlow: false,                // No longer in edit flow\n    components: [...]\n  },\n  lastUserMessage: null                 // Included for consistency\n}\n\n// Backend actions performed:\n// 1. Detected section completion during edit flow\n// 2. Retrieved edit_return_position = { section: "channels", substep: "channels" }\n// 3. Cleared edit context (is_in_edit_flow = false, edit_return_position = null)\n// 4. Navigated back to original position\n// 5. No new bot message (user resumes from where they left off)\n\n// Frontend action:\n// - Navigate back to channels substep\n// - Hide edit context UI\n// - Show success message: "Business identity updated"\n// - User continues normal flow from channels\n'})}),"\n",(0,i.jsx)(n.h4,{id:"pattern-5-edit-requiring-plan-upgrade",children:"Pattern 5: Edit Requiring Plan Upgrade"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Request:\nPOST /copilot/edit/teamSize\n{\n  substepId: "teamSize",\n  newValue: "21"  // User on BUSINESS plan (max 10 seats)\n}\n\n// Response:\n{\n  currentSubstep: {\n    id: "teamSizeOverLimit",            // Navigated to upgrade flow\n    botMessage: [\n      {\n        type: "text",\n        message: "Your current plan doesn\'t support team size \\"21 or more\\"."\n      },\n      {\n        type: "text",\n        message: "Your BUSINESS plan allows up to 10 seats. To add 21 or more..."\n      }\n    ],\n    options: [\n      { label: "Upgrade my plan", value: "upgrade", ... },\n      { label: "View plan details", value: "planDetails", ... },\n      { label: "Choose a smaller size", value: "smaller", ... }\n    ]\n  },\n  uiDirectives: {\n    isInEditFlow: true,                 // \u2705 If cross-section\n    editComplete: false,\n    components: [...]\n  },\n  lastUserMessage: {\n    messageType: "USER_EDIT",\n    content: "21 or more",\n    metadata: {\n      section: "teamMembers",\n      substep: "teamSize",\n      action: "edit",\n      formField: "team_size",\n      previousValue: "2-5"\n    },\n    createdAt: "2024-01-15T11:15:00Z"\n  }\n}\n\n// Backend actions performed:\n// 1. Validated new size against plan: validateTeamSizeAgainstPlan()\n// 2. Validation failed: requires upgrade\n// 3. Stored team_size_attempt = "21", team_size_attempt_label = "21 or more"\n// 4. Did NOT update team_size (validation failed)\n// 5. Navigated to teamSizeOverLimit\n// 6. Set edit context if cross-section\n\n// Frontend action:\n// - Navigate to upgrade flow\n// - User must complete upgrade or select smaller size\n// - team_size only updates after validation passes\n'})}),"\n",(0,i.jsx)(n.h4,{id:"pattern-6-edit-to-manual-setup-exit",children:"Pattern 6: Edit to Manual Setup Exit"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Request:\nPOST /copilot/edit/confirmChannelsConfiguration\n{\n  substepId: "confirmChannelsConfiguration",\n  newValue: false  // Switch from recommended to manual\n}\n\n// Response:\n{\n  currentSubstep: null,                 // \u2705 No next substep\n  uiDirectives: {\n    editComplete: true,                 // \u2705 Edit finished\n    exitToManualSetup: true,            // \u2705 Exit to manual UI\n    isInEditFlow: false\n  },\n  lastUserMessage: {\n    messageType: "USER_EDIT",\n    content: "Configure now (Manual Setup)",\n    metadata: {\n      section: "channels",\n      substep: "confirmChannelsConfiguration",\n      action: "edit",\n      formField: "useRecommendedSettings",\n      previousValue: true\n    },\n    createdAt: "2024-01-15T11:20:00Z"\n  }\n}\n\n// Backend actions performed:\n// 1. Updated useRecommendedSettings = false\n// 2. Cleaned up all draft assistants and configs\n// 3. Cleared edit context\n// 4. Did NOT mark conversation complete\n\n// Frontend action:\n// - Navigate to /channels/configure (manual setup UI)\n// - Conversation remains active (user can return to copilot later via restart)\n\n#### Pattern 7: Edit with Sub-Select Values\n\n// Current position: automation/finalizeSetup\n// User edits: addAutomations to add different automations\n\n// Request:\nPOST /copilot/edit/addAutomations\n{\n  substepId: "addAutomations",\n  newValue: "yes",\n  subSelectValues: ["Tag new leads", "Auto-respond after hours"]\n}\n\n// Response:\n{\n  currentSubstep: {\n    id: "confirmAIAutomations",          // Navigated to confirmation\n    botMessage: [\n      {\n        type: "text",\n        message: "Updated automation selections: Tag new leads, Auto-respond after hours."\n      },\n      {\n        type: "text",\n        message: "Great, I\'ll add these automations: Tag new leads, Auto-respond after hours"\n      }\n    ]\n  },\n  uiDirectives: {\n    isInEditFlow: false,                 // Same section\n    editComplete: false,                 // Must re-confirm\n    components: []\n  }\n}\n\n// Backend actions:\n// 1. Updated selected_automations in collected_data\n// 2. Cleared confirmAIAutomations from completed_substeps\n// 3. Navigated to confirmAIAutomations\n// 4. User must re-confirm (triggers automation creation)\n\n// To skip instead:\nPOST /copilot/edit/addAutomations\n{\n  substepId: "addAutomations",\n  newValue: "false"\n  // No subSelectValues needed\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-specific-endpoints",children:"Edit-Specific Endpoints"}),"\n",(0,i.jsx)(n.h4,{id:"edit-logo-multipart",children:"Edit Logo (Multipart)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'POST /copilot/edit-logo\nContent-Type: multipart/form-data\n\nRequest:\n{\n  logo: File,                           // Max 5MB, PNG/JPG/WEBP\n  substepId: "businessNotListed"        // Or "confirmBusinessData" if editing after match\n}\n\nResponse: CopilotResponseDto\n{\n  currentSubstep: {\n    id: "confirmBusinessData",          // Current substep (may be unchanged)\n    botMessage: [\n      {\n        type: "text",\n        message: "Logo updated successfully."\n      },\n      // ... rest of original bot message\n    ]\n  },\n  uiDirectives: {\n    editComplete: true,\n    components: [\n      {\n        name: "businessLogo",\n        metadata: {\n          logoUrl: "https://s3.../new-logo.png",  // Updated URL\n          businessName: "Acme Electronics",\n          website: "https://acme.com"\n        }\n      }\n    ]\n  },\n  lastUserMessage: {\n    messageType: "USER_EDIT",\n    content: "Logo updated",\n    metadata: {\n      section: "businessIdentity",\n      substep: "businessNotListed",     // Or substepId from request\n      action: "edit",\n      formField: "business_logo",\n      previousValue: "https://s3.../old-logo.png"\n    },\n    createdAt: "2024-01-15T11:25:00Z"\n  }\n}\n\n// Backend actions performed:\n// 1. Validated file type and size\n// 2. Deleted old logo from S3 (if exists)\n// 3. Uploaded new logo to S3\n// 4. Updated business_logo in collected_data\n// 5. Updated selected_business.logo_url if exists\n// 6. Added to edit_history\n\n// Frontend action:\n// - Update logo display\n// - Show confirmation message\n// - Stay on current screen (same section edit)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"change-plan-special-edit",children:"Change Plan (Special Edit)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'POST /copilot/change-plan\n{\n  newPlan: "ORGANISATION"  // PlanType enum\n}\n\nResponse: CopilotResponseDto\n{\n  currentSubstep: {\n    id: "businessIndustry",             // First substep OR first affected substep\n    botMessage: [...]\n  },\n  uiDirectives: {\n    components: [...]\n  }\n}\n\n// Backend actions performed:\n// 1. Switched user plan via planFeaturesService.switchPlan()\n// 2. Updated selected_plan in collected_data\n// 3. Revalidated ALL plan-dependent data:\n//    - team_size against new plan limits\n//    - channels against new plan features\n//    - AI assistants against new plan limits\n// 4. Cleared invalidated fields and substeps\n// 5. Determined affected substeps\n// 6. If completed planConfirmation: added to edit_history\n// 7. Navigated to first affected substep OR next substep\n\n// Special behaviors:\n// - If called before planConfirmation complete: normal flow advancement\n// - If called after planConfirmation: triggers revalidation cascade\n// - May clear team_size if new plan has lower limit\n// - May disable channels if new plan lacks addons\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-validation-rules",children:"Edit Validation Rules"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Validation Order (same 7-phase system applies):\n\nPhase 1: Entry Validation\n- Active conversation exists\n- User owns conversation\n\nPhase 2: Edit-Specific Validation\nLocation: validateEdit()\nChecks:\n- substepId exists in flow config\n- substepId has been completed (in completed_substeps)\n- substep.canEdit !== false\n- newValue type matches substep requirements\n- User not already in edit flow (no nested edits)\n\nExample error:\n{\n  message: "Edit validation failed",\n  errors: [\n    "Substep \'planConfirmation\' cannot be edited (use change-plan endpoint)",\n    "Substep \'businessName\' not yet completed"\n  ],\n  substepId: "planConfirmation",\n  currentState: {\n    section: "businessIdentity",\n    substep: "confirmBusinessData"\n  }\n}\n\nPhase 3: Plan Validation (if applicable)\n- Same as normal flow\n- New value must meet plan requirements\n- May trigger upgrade flow\n\nPhase 4: Text/Choice Validation (if applicable)\n- Same as normal flow\n- newValue must be valid for substep type\n\nPhase 7: Context Validation\nLocation: validateEditContext()\nChecks:\n- Edit return position is valid substep\n- Affected substeps exist in flow\n- No circular edit dependencies\n\nExample error:\n{\n  message: "Invalid edit context",\n  editSubstep: "businessIndustry",\n  returnPosition: "channels/invalidSubstep",\n  hint: "Return position no longer exists in flow"\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-error-responses",children:"Edit Error Responses"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Cannot Edit Error:\nStatus: 400 Bad Request\n{\n  message: "This substep cannot be edited",\n  substepId: "planConfirmation",\n  reason: "Use POST /copilot/change-plan to change your plan",\n  canEdit: false\n}\n\n// Not Completed Error:\nStatus: 400 Bad Request\n{\n  message: "Cannot edit incomplete substep",\n  substepId: "channels",\n  currentState: {\n    section: "businessIdentity",\n    substep: "businessName"\n  },\n  hint: "Complete this substep first before editing"\n}\n\n// Nested Edit Error:\nStatus: 400 Bad Request\n{\n  message: "Cannot edit while in edit flow",\n  currentEditContext: {\n    editedSubstep: "businessIndustry",\n    affectedSubsteps: ["confirmBusinessData"]\n  },\n  hint: "Complete current edit flow before starting a new edit"\n}\n\n// Invalid Value Error:\nStatus: 400 Bad Request\n{\n  message: "Invalid edit value",\n  substepId: "channels",\n  errors: [\n    "At least one channel must be selected"\n  ],\n  providedValue: [],\n  validation: "Array length >= 1"\n}\n\n// Plan Validation Error (triggers upgrade flow instead of error):\nStatus: 200 OK  // Not an error - navigation response\n{\n  currentSubstep: {\n    id: "teamSizeOverLimit",\n    // ... upgrade flow\n  },\n  uiDirectives: {\n    isInEditFlow: true  // If cross-section\n  }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 2, Section A Complete"})}),"\n",(0,i.jsx)(n.p,{children:"This section covered:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Edit endpoint structure and request/response formats"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Edit value types for all editable substeps"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Six distinct edit response patterns"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Special edit endpoints (logo, plan change)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Edit-specific validation rules"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Comprehensive error responses"}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"section-b-edit-state-management",children:"Section B: Edit State Management"}),"\n",(0,i.jsx)(n.h2,{id:"edit-context-lifecycle",children:"Edit Context Lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"edit-context-structure",children:"Edit Context Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'interface EditContext {\n  // Stored in conversation.sessionState:\n  is_in_edit_flow: boolean              // Flag indicating active edit\n  edit_return_position: {               // Where to return after edit completes\n    section: string,\n    substep: string\n  } | null\n  affected_substeps_in_edit: string[]   // Substeps cleared/requiring update\n}\n\n// Example state during cross-section edit:\n{\n  current_section: "businessIdentity",\n  current_substep: "confirmBusinessData",\n  is_in_edit_flow: true,\n  edit_return_position: {\n    section: "channels",\n    substep: "channels"\n  },\n  affected_substeps_in_edit: [\n    "confirmBusinessData",\n    "adjustGoalsObjectives"\n  ],\n  completed_substeps: [\n    "planConfirmation",\n    "businessIndustry",\n    "businessName",\n    "selectBusinessNameMatch",\n    // confirmBusinessData was cleared (affected by edit)\n    "channels"  // Original position\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"when-edit-context-is-set",children:"When Edit Context Is Set"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Edit context is ONLY set for cross-section edits\n// Determined by: shouldSetEditContext calculation\n\nconst shouldSetEditContext =\n  !isSameSection ||                    // Different section\n  editImpact?.affectedSubsteps?.length > 0;  // Has affected substeps\n\n// Pattern 1: Same section, no affected substeps\nEdit businessIndustry from businessIdentity section:\n\u2192 isSameSection = true\n\u2192 affectedSubsteps = ["confirmBusinessData", "adjustGoalsObjectives"]\n\u2192 shouldSetEditContext = true (has affected substeps)\n\u2192 Set edit context\n\n// Pattern 2: Same section, inline edit\nEdit noReplyConfiguration from fallbackLogic section:\n\u2192 isSameSection = true\n\u2192 affectedSubsteps = []\n\u2192 shouldSetEditContext = false\n\u2192 NO edit context (inline edit)\n\n// Pattern 3: Cross-section edit\nEdit businessIndustry from channels section:\n\u2192 isSameSection = false\n\u2192 affectedSubsteps = ["confirmBusinessData", "adjustGoalsObjectives"]\n\u2192 shouldSetEditContext = true (different section)\n\u2192 Set edit context\n\n// Backend implementation:\nif (shouldSetEditContext) {\n  await stateService.setEditContext(\n    conversationId,\n    { section: currentSection, substep: currentSubstep },  // Return position\n    editImpact.affectedSubsteps                            // Affected substeps\n  )\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-context-state-transitions",children:"Edit Context State Transitions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Transition 1: Normal Flow \u2192 Edit Flow\nState before edit:\n{\n  current_section: "channels",\n  current_substep: "confirmChannelsConfiguration",\n  is_in_edit_flow: false,\n  edit_return_position: null\n}\n\nUser edits: businessIndustry \u2192 "HEALTHCARE_CLINICS"\n\nState after edit:\n{\n  current_section: "businessIdentity",        // Navigated to affected section\n  current_substep: "confirmBusinessData",     // First affected substep\n  is_in_edit_flow: true,                      // \u2705 Edit flow active\n  edit_return_position: {                     // \u2705 Return position stored\n    section: "channels",\n    substep: "confirmChannelsConfiguration"\n  },\n  affected_substeps_in_edit: [\n    "confirmBusinessData",\n    "adjustGoalsObjectives"\n  ]\n}\n\n// Transition 2: Edit Flow \u2192 Completing Affected Substep\nUser completes: confirmBusinessData (first affected substep)\n\nCheck: More affected substeps remaining?\n\u2192 adjustGoalsObjectives still pending\n\u2192 Navigate to adjustGoalsObjectives\n\u2192 Stay in edit flow\n\nState after completion:\n{\n  current_section: "businessIdentity",\n  current_substep: "adjustGoalsObjectives",   // Next affected substep\n  is_in_edit_flow: true,                      // Still in edit flow\n  edit_return_position: {                     // Still set\n    section: "channels",\n    substep: "confirmChannelsConfiguration"\n  }\n}\n\n// Transition 3: Edit Flow \u2192 Return to Origin\nUser completes: adjustGoalsObjectives (last affected substep)\n\nBackend detects:\n- Section completion triggered (end of businessIdentity)\n- is_in_edit_flow === true\n- edit_return_position exists\n\nBackend executes return:\nawait stateService.clearEditContext(conversationId)\nawait stateService.updateCurrentPosition(\n  conversationId,\n  "channels",\n  "confirmChannelsConfiguration"\n)\n\nState after return:\n{\n  current_section: "channels",\n  current_substep: "confirmChannelsConfiguration",\n  is_in_edit_flow: false,                     // \u2705 Cleared\n  edit_return_position: null,                 // \u2705 Cleared\n  affected_substeps_in_edit: []               // \u2705 Cleared\n}\n\nResponse to user:\n{\n  currentSubstep: {\n    id: "confirmChannelsConfiguration",\n    botMessage: []  // Empty - already displayed\n  },\n  uiDirectives: {\n    editComplete: true,\n    returnedFromEdit: true,\n    isInEditFlow: false\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"edit-context-clearing-triggers",children:"Edit Context Clearing Triggers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Edit context is cleared in these scenarios:\n\n1. Successful Edit Return\nLocation: handleSectionComplete() OR handleConfirmBusinessData()\nCondition: is_in_edit_flow && edit_return_position exists\nAction: Navigate to return position, clear context\n\n2. Exit to Manual Setup\nLocation: handleConfirmChannelsConfiguration() with false\nCondition: User selects "Configure now (Manual Setup)"\nAction: Clear context, exit conversation\n\n3. Conversation Restart\nLocation: restartConversation()\nCondition: Always\nAction: Full state reset, clear all edit context\n\n4. Conversation Completion\nLocation: handleFinalizeSetup() OR handleConfirmAutomations()\nCondition: User completes final substep\nAction: Mark complete, clear context\n\n// Edit context is NOT cleared when:\n- User completes non-affected substep during edit\n- User navigates between affected substeps\n- Validation error occurs\n- User adds/deletes assistants during edit\n\n// Implementation:\nasync clearEditContext(conversationId: number) {\n  await this.prisma.copilotConversation.update({\n    where: { id: conversationId },\n    data: {\n      sessionState: {\n        ...currentState,\n        is_in_edit_flow: false,\n        edit_return_position: null,\n        affected_substeps_in_edit: []\n      }\n    }\n  })\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"edit-impact-chains",children:"Edit Impact Chains"}),"\n",(0,i.jsx)(n.h3,{id:"edit-impact-map",children:"Edit Impact Map"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Defined in: copilot/config/edit-impact.config.ts\n\nexport const EDIT_IMPACT_MAP: Record<string, EditImpact> = {\n  // Business Identity Section\n  businessIndustry: {\n    affectedSubsteps: ["confirmBusinessData", "adjustGoalsObjectives"],\n    clearedFields: [\n      "suggested_goals",\n      "suggested_objectives",\n      "ai_summary",\n      "business_search_results",\n    ],\n    customHandler: "handleIndustryEdit",\n    reason: "Industry change requires goal regeneration",\n  },\n\n  businessName: {\n    affectedSubsteps: [\n      "selectBusinessNameMatch",\n      "confirmBusinessData",\n      "adjustGoalsObjectives",\n    ],\n    clearedFields: [\n      "business_search_results",\n      "selected_business",\n      "business_logo",\n      "suggested_goals",\n      "suggested_objectives",\n      "ai_summary",\n    ],\n    customHandler: "handleBusinessNameEdit",\n    reason: "Business name change triggers new search and goal regeneration",\n  },\n\n  selectBusinessNameMatch: {\n    affectedSubsteps: ["confirmBusinessData", "adjustGoalsObjectives"],\n    clearedFields: ["suggested_goals", "suggested_objectives", "ai_summary"],\n    customHandler: "handleBusinessMatchEdit",\n    reason: "Business match change requires goal regeneration",\n  },\n\n  adjustGoalsObjectives: {\n    affectedSubsteps: ["adjustGoalsConfirm"],\n    clearedFields: [],\n    customHandler: "handleAdjustGoalsEdit",\n    reason: "Goals adjustment affects confirmation step",\n  },\n\n  // Team Members Section\n  teamSize: {\n    affectedSubsteps: [], // May trigger upgrade flow instead\n    clearedFields: [],\n    customHandler: "handleTeamSizeEdit",\n    reason: "Team size may require plan validation",\n  },\n\n  // Channels Section\n  channels: {\n    affectedSubsteps: [\n      "confirmChannelsConfiguration",\n      "aiAssistantsForChannels",\n      "beezaroAssistants",\n    ],\n    clearedFields: [\n      "draft_channel_configs",\n      "created_assistants",\n      "aiAssistantsForChannels",\n      "business_search_results",\n    ],\n    customHandler: "handleChannelsEdit",\n    reason: "Channel changes affect entire AI assistant setup",\n  },\n\n  confirmChannelsConfiguration: {\n    affectedSubsteps: ["noReplyConfiguration", "beezaroAssistants"],\n    clearedFields: ["draft_channel_configs", "created_assistants"],\n    customHandler: "handleChannelConfigStrategyEdit",\n    reason: "Config strategy change rebuilds entire setup",\n  },\n\n  // Fallback Logic Section\n  noReplyConfiguration: {\n    affectedSubsteps: [],\n    clearedFields: [],\n    customHandler: "handleNoReplyConfigEdit",\n    reason: "Updates existing draft configs in-place",\n  },\n\n  // AI Assistant Section\n  aiAssistantsForChannels: {\n    affectedSubsteps: ["beezaroAssistants"],\n    clearedFields: ["created_assistants", "draft_channel_configs"],\n    customHandler: "handleAssistantStrategyEdit",\n    reason: "Strategy change rebuilds all assistants and assignments",\n  },\n\n  // Plan Change (special)\n  planConfirmation: {\n    affectedSubsteps: [], // Dynamically determined\n    clearedFields: [], // Dynamically determined based on revalidation\n    customHandler: "handlePlanChange",\n    reason: "Plan change triggers comprehensive revalidation",\n  },\n\n  // Automations section\n  addAutomations: {\n    affectedSubsteps: ["confirmAIAutomations"],\n    clearedFields: ["selected_automations"],\n    customHandler: "handleAddAutomationsEdit",\n    reason: "Automation changes require re-confirmation before creation",\n  },\n};\n\n// Helper function to get edit impact:\nexport function getEditImpact(substepId: string): EditImpact | null {\n  return EDIT_IMPACT_MAP[substepId] || null;\n}\n\n// Helper function to get section for substep:\nexport function getSectionForSubstep(\n  substepId: string,\n  flowConfig: FlowConfig\n): string {\n  for (const [sectionId, section] of Object.entries(flowConfig)) {\n    if (section.subSteps[substepId]) {\n      return sectionId;\n    }\n  }\n  throw new Error(`Substep ${substepId} not found in flow config`);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"impact-chain-execution",children:"Impact Chain Execution"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// When edit is processed:\n\n1. Retrieve Edit Impact\nconst editImpact = getEditImpact(editDto.substepId)\n\n2. Clear Affected Substeps\nif (editImpact?.affectedSubsteps?.length) {\n  // Remove from completed_substeps\n  await stateService.clearAffectedSubsteps(\n    conversationId,\n    editImpact.affectedSubsteps\n  )\n\n  // Implementation:\n  // Filter out affected substeps from completed_substeps array\n  const newCompleted = state.completed_substeps.filter(\n    s => !affectedSubsteps.includes(s)\n  )\n}\n\n3. Clear Affected Data\nif (editImpact?.clearedFields?.length) {\n  await stateService.clearAffectedCollectedData(\n    conversationId,\n    editImpact.clearedFields\n  )\n\n  // Implementation:\n  // Set each field to null in collected_data\n  for (const field of clearedFields) {\n    collected_data[field] = null\n  }\n}\n\n4. Execute Custom Handler (if exists)\nif (editImpact?.customHandler) {\n  return await this[editImpact.customHandler](\n    conversationId,\n    newValue,\n    state,\n    targetSubstep,\n    oldValue\n  )\n}\n\n5. Navigate to First Affected Substep\nconst firstAffected = editImpact.affectedSubsteps[0]\nconst affectedSection = getSectionForSubstep(firstAffected, flowConfig)\n\nawait stateService.updateCurrentPosition(\n  conversationId,\n  affectedSection,\n  firstAffected\n)\n\n6. Set Edit Context (if cross-section)\nif (shouldSetEditContext) {\n  await stateService.setEditContext(\n    conversationId,\n    { section: currentSection, substep: currentSubstep },\n    editImpact.affectedSubsteps\n  )\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"cascading-impact-example",children:"Cascading Impact Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Example: Edit businessName from channels section\n\nInitial State:\n{\n  current_section: "channels",\n  current_substep: "channels",\n  collected_data: {\n    business_name: "Old Business",\n    business_search_results: [...],\n    selected_business: {...},\n    suggested_goals: [...],\n    channels: ["whatsapp"],\n    ...\n  },\n  completed_substeps: [\n    "planConfirmation",\n    "businessIndustry",\n    "businessName",\n    "selectBusinessNameMatch",\n    "confirmBusinessData",\n    "channels"\n  ]\n}\n\nUser Edit:\nPOST /copilot/edit/businessName\n{ newValue: "New Business Inc" }\n\nEdit Impact Retrieval:\n{\n  affectedSubsteps: [\n    "selectBusinessNameMatch",\n    "confirmBusinessData",\n    "adjustGoalsObjectives"\n  ],\n  clearedFields: [\n    "business_search_results",\n    "selected_business",\n    "business_logo",\n    "suggested_goals",\n    "suggested_objectives",\n    "ai_summary"\n  ],\n  customHandler: "handleBusinessNameEdit"\n}\n\nExecution Steps:\n\nStep 1: Update business_name\ncollected_data.business_name = "New Business Inc"\n\nStep 2: Clear affected fields\ncollected_data.business_search_results = null\ncollected_data.selected_business = null\ncollected_data.business_logo = null\ncollected_data.suggested_goals = null\ncollected_data.suggested_objectives = null\ncollected_data.ai_summary = null\n\nStep 3: Clear affected substeps\ncompleted_substeps = [\n  "planConfirmation",\n  "businessIndustry",\n  "businessName",\n  // selectBusinessNameMatch REMOVED\n  // confirmBusinessData REMOVED\n  "channels"  // Still completed\n]\n\nStep 4: Perform new business search\nconst matches = await businessLookupService.searchBusiness("New Business Inc")\ncollected_data.business_search_results = matches\n\nStep 5: Set edit context (cross-section)\nis_in_edit_flow = true\nedit_return_position = { section: "channels", substep: "channels" }\naffected_substeps_in_edit = [\n  "selectBusinessNameMatch",\n  "confirmBusinessData",\n  "adjustGoalsObjectives"\n]\n\nStep 6: Navigate to first affected substep\ncurrent_section = "businessIdentity"\ncurrent_substep = "selectBusinessNameMatch"\n\nStep 7: Record edit history\nedit_history.push({\n  timestamp: "2024-01-15T11:30:00Z",\n  section: "businessIdentity",\n  substep: "businessName",\n  field: "business_name",\n  old_value: "Old Business",\n  new_value: "New Business Inc",\n  affected_substeps: [\n    "selectBusinessNameMatch",\n    "confirmBusinessData",\n    "adjustGoalsObjectives"\n  ]\n})\n\nFinal State:\n{\n  current_section: "businessIdentity",\n  current_substep: "selectBusinessNameMatch",\n  is_in_edit_flow: true,\n  edit_return_position: {\n    section: "channels",\n    substep: "channels"\n  },\n  affected_substeps_in_edit: [\n    "selectBusinessNameMatch",\n    "confirmBusinessData",\n    "adjustGoalsObjectives"\n  ],\n  collected_data: {\n    business_name: "New Business Inc",\n    business_search_results: [...],  // New search results\n    selected_business: null,         // Cleared\n    suggested_goals: null,           // Cleared\n    channels: ["whatsapp"],          // Preserved\n    ...\n  },\n  completed_substeps: [\n    "planConfirmation",\n    "businessIndustry",\n    "businessName",\n    "channels"\n  ]\n}\n\nUser Flow After Edit:\n1. User sees selectBusinessNameMatch with new search results\n2. User selects a match \u2192 advances to confirmBusinessData\n3. Backend regenerates goals based on new business\n4. User confirms \u2192 advances to adjustGoalsObjectives (if selected)\n5. User completes adjustGoalsObjectives\n6. Section completes \u2192 backend detects edit flow\n7. Backend returns to channels substep\n8. User resumes normal flow from channels\n'})}),"\n",(0,i.jsx)(n.h2,{id:"edit-history-tracking",children:"Edit History Tracking"}),"\n",(0,i.jsx)(n.h3,{id:"edit-history-structure",children:"Edit History Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'interface EditHistoryEntry {\n  timestamp: string; // ISO 8601 timestamp\n  section: string; // Section of edited substep\n  substep: string; // Edited substep ID\n  field: string; // formField that was changed\n  old_value: any; // Previous value\n  new_value: any; // New value\n  affected_substeps: string[]; // Substeps cleared by this edit\n}\n\n// Stored in: conversation.sessionState.edit_history[]\n\n// Example edit_history:\nedit_history: [\n  {\n    timestamp: "2024-01-15T10:30:00Z",\n    section: "businessIdentity",\n    substep: "businessIndustry",\n    field: "industry",\n    old_value: "ECOMMERCE_RETAIL",\n    new_value: "HEALTHCARE_CLINICS",\n    affected_substeps: ["confirmBusinessData", "adjustGoalsObjectives"],\n  },\n  {\n    timestamp: "2024-01-15T11:15:00Z",\n    section: "channels",\n    substep: "channels",\n    field: "channels",\n    old_value: ["whatsapp"],\n    new_value: ["whatsapp", "gmail", "slack"],\n    affected_substeps: [\n      "confirmChannelsConfiguration",\n      "aiAssistantsForChannels",\n      "beezaroAssistants",\n    ],\n  },\n];\n'})}),"\n",(0,i.jsx)(n.h3,{id:"when-edit-history-is-recorded",children:"When Edit History Is Recorded"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Edit history is ALWAYS recorded during edits\n\nawait stateService.addEditHistory(conversationId, {\n  section: targetSection,\n  substep: editDto.substepId,\n  field: targetSubstep.formField,\n  old_value: oldValue,\n  new_value: editDto.newValue,\n  affected_substeps: editImpact?.affectedSubsteps || []\n})\n\n// Implementation:\nasync addEditHistory(conversationId: number, entry: EditHistoryEntry) {\n  const conversation = await this.getConversationById(conversationId)\n  const state = parseSessionState(conversation.sessionState)\n\n  state.edit_history = state.edit_history || []\n  state.edit_history.push({\n    ...entry,\n    timestamp: new Date().toISOString()\n  })\n\n  await this.prisma.copilotConversation.update({\n    where: { id: conversationId },\n    data: { sessionState: state }\n  })\n}\n\n// NOT recorded for:\n- Normal flow progression (only edits)\n- Assistant add/delete (separate tracking)\n- File uploads during normal flow (only edit uploads)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"edit-history-use-cases",children:"Edit History Use Cases"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Use Case 1: Audit Trail\n// Frontend can display edit history to user\n\nfunction EditHistoryTimeline({ history }) {\n  return (\n    <div>\n      <h3>Your Changes</h3>\n      {history.map((entry) => (\n        <div key={entry.timestamp}>\n          <time>{formatTime(entry.timestamp)}</time>\n          <p>\n            Updated {entry.field} in {entry.substep}\n            <br />\n            From: {JSON.stringify(entry.old_value)}\n            <br />\n            To: {JSON.stringify(entry.new_value)}\n          </p>\n          {entry.affected_substeps.length > 0 && (\n            <p>Affected: {entry.affected_substeps.join(", ")}</p>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Use Case 2: Undo Functionality (Future Enhancement)\n// Edit history provides data for potential undo feature\n\nasync function undoLastEdit(conversationId: number) {\n  const state = await getState(conversationId);\n  const lastEdit = state.edit_history[state.edit_history.length - 1];\n\n  if (!lastEdit) return;\n\n  // Restore old value\n  await editSubstep(conversationId, {\n    substepId: lastEdit.substep,\n    newValue: lastEdit.old_value,\n  });\n\n  // Remove from history\n  state.edit_history.pop();\n}\n\n// Use Case 3: Change Detection\n// Detect if user has made any edits\n\nfunction hasUserMadeEdits(state: CopilotSessionState): boolean {\n  return state.edit_history?.length > 0;\n}\n\nfunction getEditCount(state: CopilotSessionState): number {\n  return state.edit_history?.length || 0;\n}\n\n// Use Case 4: Section-Specific Edit Count\n// Track edits per section for analytics\n\nfunction getEditsBySection(\n  history: EditHistoryEntry[]\n): Record<string, number> {\n  return history.reduce((acc, entry) => {\n    acc[entry.section] = (acc[entry.section] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n}\n\n// Example:\n// {\n//   businessIdentity: 2,\n//   channels: 1,\n//   teamMembers: 1\n// }\n'})}),"\n",(0,i.jsx)(n.h2,{id:"return-flow-navigation",children:"Return Flow Navigation"}),"\n",(0,i.jsx)(n.h3,{id:"return-flow-decision-tree",children:"Return Flow Decision Tree"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// At section completion, backend checks:\n\nif (state.is_in_edit_flow && state.edit_return_position) {\n  // RETURN FLOW: Navigate back to origin\n\n  const { section, substep } = state.edit_return_position\n\n  await stateService.clearEditContext(conversationId)\n  await stateService.updateCurrentPosition(conversationId, section, substep)\n\n  return {\n    currentSubstep: await getSubstep(section, substep),\n    uiDirectives: {\n      editComplete: true,\n      returnedFromEdit: true,\n      isInEditFlow: false,\n      components: []\n    }\n  }\n\n} else {\n  // NORMAL FLOW: Advance to next section\n\n  const nextSection = await flowService.getNextSection(currentSection)\n\n  if (!nextSection) {\n    await stateService.completeConversation(conversationId)\n    return {\n      currentSubstep: null,\n      conversationComplete: true\n    }\n  }\n\n  const entrySubstep = await flowService.getSubstep(\n    nextSection,\n    section.entry\n  )\n\n  await stateService.updateCurrentPosition(\n    conversationId,\n    nextSection,\n    section.entry\n  )\n\n  return {\n    currentSubstep: entrySubstep,\n    sectionComplete: true,\n    uiDirectives: {\n      components: [...]\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"return-flow-scenarios",children:"Return Flow Scenarios"}),"\n",(0,i.jsx)(n.h4,{id:"scenario-1-simple-return-all-affected-substeps-in-same-section",children:"Scenario 1: Simple Return (All Affected Substeps in Same Section)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Setup:\nCurrent position: channels/channels\nUser edits: businessIndustry\nAffected substeps: confirmBusinessData, adjustGoalsObjectives\nBoth affected substeps in: businessIdentity section\n\n// Execution:\n1. User completes confirmBusinessData\n   \u2192 Advances to adjustGoalsObjectives (still in businessIdentity)\n\n2. User completes adjustGoalsObjectives\n   \u2192 Section completes (end of businessIdentity)\n   \u2192 Backend detects edit flow\n   \u2192 Returns to channels/channels\n\n3. Response:\n{\n  currentSubstep: { id: "channels", botMessage: [] },\n  uiDirectives: {\n    editComplete: true,\n    returnedFromEdit: true,\n    isInEditFlow: false\n  }\n}\n\n// User sees: Original channels screen, no new bot message\n'})}),"\n",(0,i.jsx)(n.h4,{id:"scenario-2-multi-section-return-affected-substeps-span-sections",children:"Scenario 2: Multi-Section Return (Affected Substeps Span Sections)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Setup:\nCurrent position: automation/addAutomations\nUser edits: channels (removes WhatsApp, adds Slack)\nAffected substeps:\n  - confirmChannelsConfiguration (channels section)\n  - aiAssistantsForChannels (aiAssistant section)\n  - beezaroAssistants (aiAssistant section)\n\n// Execution:\n1. User completes confirmChannelsConfiguration\n   \u2192 Section completes (end of channels)\n   \u2192 Still in edit flow (more affected substeps)\n   \u2192 Advances to aiAssistant/aiAssistantsForChannels\n\n2. User completes aiAssistantsForChannels\n   \u2192 Advances to beezaroAssistants (still in aiAssistant)\n\n3. User completes beezaroAssistants\n   \u2192 Section completes (end of aiAssistant)\n   \u2192 Backend detects edit flow complete\n   \u2192 Returns to automation/addAutomations\n\n4. Response:\n{\n  currentSubstep: { id: "addAutomations", botMessage: [] },\n  uiDirectives: {\n    editComplete: true,\n    returnedFromEdit: true,\n    isInEditFlow: false\n  }\n}\n\n// Note: User navigated through 2 sections during edit,\n// then returned to original position in 3rd section\n'})}),"\n",(0,i.jsx)(n.h4,{id:"scenario-3-return-with-dynamic-rehydration",children:"Scenario 3: Return with Dynamic Rehydration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Setup:\nCurrent position: aiAssistant/beezaroAssistants\nUser edits: channels (adds new channel)\nReturn position: aiAssistant/beezaroAssistants\n\n// Special case: beezaroAssistants needs updated assistant data\n\n// Execution:\n1. User completes channel edit flow\n   \u2192 New assistants created for new channels\n   \u2192 Returns to beezaroAssistants\n\n2. Backend rehydrates return substep:\nconst returnSubstep = await getSubstep("aiAssistant", "beezaroAssistants")\n\n// Fetch fresh assistant data\nconst assistants = await prisma.aiAssistant.findMany({\n  where: { userId, onboardingDraft: true }\n})\n\n// Build fresh bot message with updated assistant cards\nconst botMessage = [\n  {\n    type: "component",\n    component: "CopilotContext",\n    metadata: { event: "edit_complete" }\n  },\n  ...assistants.map(a => ({\n    type: "component",\n    component: "AssistantCard",\n    metadata: { id: a.id, name: a.name, onboardingDraft: true }\n  }))\n]\n\n3. Response:\n{\n  currentSubstep: {\n    id: "beezaroAssistants",\n    botMessage: botMessage  // \u2705 Fresh assistant data\n  },\n  uiDirectives: {\n    editComplete: true,\n    returnedFromEdit: true,\n    components: [...]  // Updated components\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"scenario-4-return-after-upgrade-flow",children:"Scenario 4: Return After Upgrade Flow"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Setup:\nCurrent position: channels/channels\nUser edits: teamSize \u2192 "21" (requires upgrade)\nEdit triggers: teamSizeOverLimit \u2192 teamUpgradeOptions \u2192 teamUpgradeConfirm\n\n// Execution:\n1. User at teamUpgradeConfirm\n   \u2192 Validates team size now fits new plan\n   \u2192 Marks teamSize as complete\n   \u2192 Checks edit context: is_in_edit_flow = true\n\n2. Backend detects:\n   \u2192 In edit flow\n   \u2192 No more affected substeps (upgrade flow complete)\n   \u2192 Return position: channels/channels\n\n3. Backend returns:\nawait stateService.clearEditContext(conversationId)\nawait stateService.updateCurrentPosition(\n  conversationId,\n  "channels",\n  "channels"\n)\n\n4. Response:\n{\n  currentSubstep: {\n    id: "channels",\n    botMessage: [\n      {\n        type: "text",\n        message: "Team size updated to 21 or more. Plan upgraded successfully."\n      }\n      // Original bot message omitted (already displayed)\n    ]\n  },\n  uiDirectives: {\n    editComplete: true,\n    returnedFromEdit: true,\n    isInEditFlow: false\n  }\n}\n\n// Note: Confirmation message prepended to return substep\n'})}),"\n",(0,i.jsx)(n.h3,{id:"return-position-edge-cases",children:"Return Position Edge Cases"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Edge Case 1: Return position no longer exists\n// Scenario: Flow config changed between edit start and return\n\nif (state.edit_return_position) {\n  try {\n    const returnSubstep = await getSubstep(\n      state.edit_return_position.section,\n      state.edit_return_position.substep\n    );\n  } catch (error) {\n    // Return position invalid - log and clear\n    logger.error("Invalid return position", state.edit_return_position);\n    await stateService.clearEditContext(conversationId);\n\n    // Fall back to normal flow\n    return await handleSectionComplete(conversationId, state);\n  }\n}\n\n// Edge Case 2: Return position in skipped substep\n// Scenario: User skipped substep, then edited earlier step\n\n// This shouldn\'t happen (can\'t skip during active conversation)\n// But if it does, return position is still valid\n// User returns to skipped substep (which shows previous data)\n\n// Edge Case 3: Multiple nested edits (prevented)\n// Scenario: User tries to edit while already in edit flow\n\nif (state.is_in_edit_flow) {\n  throw new BadRequestException({\n    message: "Cannot edit while in edit flow",\n    currentEditContext: {\n      editedSubstep: state.affected_substeps_in_edit[0],\n      returnPosition: state.edit_return_position,\n    },\n    hint: "Complete current edit flow before starting a new edit",\n  });\n}\n\n// Edge Case 4: Return after conversation restart\n// Scenario: User restarts conversation during edit flow\n\n// Restart clears ALL state including edit context\n// No return flow - user starts fresh from beginning\n'})}),"\n",(0,i.jsx)(n.h2,{id:"cleanup-and-data-clearing-patterns",children:"Cleanup and Data Clearing Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"field-clearing-strategies",children:"Field Clearing Strategies"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Strategy 1: Explicit Field Clearing (Most Common)\n// Used when edit impact specifies exact fields to clear\n\nconst editImpact = {\n  clearedFields: ["suggested_goals", "suggested_objectives", "ai_summary"],\n};\n\nawait stateService.clearAffectedCollectedData(\n  conversationId,\n  editImpact.clearedFields\n);\n\n// Implementation:\nfor (const field of clearedFields) {\n  state.collected_data[field] = null;\n}\n\n// Strategy 2: Transient Field Clearing (Section Boundary)\n// Used at section completion to remove temporary data\n\n// Example: End of businessIdentity section\nawait stateService.updateCollectedData(\n  conversationId,\n  "business_search_results",\n  null\n);\n\n// Strategy 3: Draft Record Cleanup (Database + State)\n// Used when channels or assistants change\n\nawait cleanupOnboardingDraftAssistantsAndConfigs(userId);\n\n// Implementation:\n// 1. Find all draft channel configs\nconst draftConfigs = await prisma.channelAiConfig.findMany({\n  where: {\n    connectedChannelId: { in: userChannelIds },\n    onboardingDraft: true,\n  },\n});\n\n// 2. Delete related records\nawait prisma.escalationKeyword.deleteMany({\n  where: { channelAiConfigId: { in: draftConfigIds } },\n});\nawait prisma.channelWorkingDay.deleteMany({\n  where: { channelAiConfigId: { in: draftConfigIds } },\n});\nawait prisma.channelAiAccess.deleteMany({\n  where: { channelAiConfigId: { in: draftConfigIds } },\n});\n\n// 3. Delete configs\nawait prisma.channelAiConfig.deleteMany({\n  where: { id: { in: draftConfigIds } },\n});\n\n// 4. Delete draft assistants\nawait prisma.aiAssistant.deleteMany({\n  where: { userId, onboardingDraft: true },\n});\n\n// 5. Clear state fields\nawait stateService.clearAffectedCollectedData(conversationId, [\n  "draft_channel_configs",\n  "created_assistants",\n]);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"substep-clearing-implementation",children:"Substep Clearing Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Clearing affected substeps from completed_substeps\n\nasync clearAffectedSubsteps(\n  conversationId: number,\n  affectedSubsteps: string[]\n) {\n  const conversation = await this.getConversationById(conversationId)\n  const state = parseSessionState(conversation.sessionState)\n\n  // Filter out affected substeps\n  state.completed_substeps = state.completed_substeps.filter(\n    substepId => !affectedSubsteps.includes(substepId)\n  )\n\n  await this.prisma.copilotConversation.update({\n    where: { id: conversationId },\n    data: { sessionState: state }\n  })\n}\n\n// Example:\nBefore edit:\ncompleted_substeps: [\n  "planConfirmation",\n  "businessIndustry",\n  "businessName",\n  "selectBusinessNameMatch",\n  "confirmBusinessData",\n  "adjustGoalsObjectives",\n  "teamSize",\n  "channels"\n]\n\nAfter editing businessIndustry:\naffectedSubsteps: ["confirmBusinessData", "adjustGoalsObjectives"]\n\nResult:\ncompleted_substeps: [\n  "planConfirmation",\n  "businessIndustry",\n  "businessName",\n  "selectBusinessNameMatch",\n  // confirmBusinessData removed\n  // adjustGoalsObjectives removed\n  "teamSize",\n  "channels"\n]\n\n// Note: User must re-complete removed substeps\n'})}),"\n",(0,i.jsx)(n.h3,{id:"channel-deletion-during-edit",children:"Channel Deletion During Edit"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Special case: User removes channels during edit\n\n// Before:\nchannels: ["whatsapp", "gmail", "slack"]\nconnected_channels: [\n  { id: 1, name: "whatsapp" },\n  { id: 2, name: "gmail" },\n  { id: 3, name: "slack" }\n]\ndraft_channel_configs: [\n  { connectedChannelId: 1, aiAssistantId: 10 },\n  { connectedChannelId: 2, aiAssistantId: 10 },\n  { connectedChannelId: 3, aiAssistantId: 11 }\n]\n\n// User edits channels to: ["whatsapp", "gmail"]\n\n// Cleanup process:\n1. Identify removed channels:\nconst removed = ["slack"]  // Difference between old and new\n\n2. Find connected channel records:\nconst channelToDelete = connectedChannels.find(\n  ch => ch.availableChannel.name === "slack"\n)\n\n3. Delete channel configs:\nawait prisma.channelAiConfig.deleteMany({\n  where: { connectedChannelId: channelToDelete.id }\n})\n\n4. Delete connected channel:\nawait prisma.connectedChannel.delete({\n  where: { id: channelToDelete.id }\n})\n\n5. Update state:\ncollected_data.channels = ["WhatsApp", "Gmail"]\ncollected_data.selected_channel_values = ["whatsapp", "gmail"]\n\n6. Cleanup and rebuild:\n// Delete ALL draft assistants and configs\nawait cleanupOnboardingDraftAssistantsAndConfigs(userId)\n\n// Rebuild with new channel count\n// (Happens in affected substep flow)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"assistant-deletion-during-edit",children:"Assistant Deletion During Edit"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Special case: User deletes assistant during beezaroAssistants\n\n// Before:\ncreated_assistants: [\n  { id: 10, name: "Beezaro Alpha" },\n  { id: 11, name: "Beezaro Swift" },\n  { id: 12, name: "Beezaro Zen" }\n]\ndraft_channel_configs: [\n  { connectedChannelId: 1, aiAssistantId: 10 },\n  { connectedChannelId: 2, aiAssistantId: 11 },\n  { connectedChannelId: 3, aiAssistantId: 12 }\n]\n\n// User deletes: Beezaro Swift (id: 11)\n\nDELETE /copilot/assistants/11\n\n// Cleanup process:\n1. Validate: At least one assistant remains\nif (remainingAssistants.length === 0) {\n  throw new BadRequestException(\n    "Cannot delete the last remaining assistant"\n  )\n}\n\n2. Delete assistant:\nawait prisma.aiAssistant.delete({ where: { id: 11 } })\n\n3. Recompute assignments:\nconst assignments = computeDraftAssignments(\n  [1, 2, 3],  // Channel IDs\n  [10, 12]    // Remaining assistant IDs\n)\n\n// Result:\n// [\n//   { connectedChannelId: 1, aiAssistantId: 10 },\n//   { connectedChannelId: 2, aiAssistantId: 12 },\n//   { connectedChannelId: 3, aiAssistantId: 12 }  // 12 takes both\n// ]\n\n4. Update channel configs:\nawait prisma.channelAiConfig.updateMany({\n  where: { connectedChannelId: 1 },\n  data: { aiAssistantId: 10 }\n})\nawait prisma.channelAiConfig.updateMany({\n  where: { connectedChannelId: 2 },\n  data: { aiAssistantId: 12 }\n})\nawait prisma.channelAiConfig.updateMany({\n  where: { connectedChannelId: 3 },\n  data: { aiAssistantId: 12 }\n})\n\n5. Update state:\ncollected_data.created_assistants = [\n  { id: 10, name: "Beezaro Alpha" },\n  { id: 12, name: "Beezaro Zen" }\n]\ncollected_data.draft_channel_configs = [\n  { connectedChannelId: 1, aiAssistantId: 10, ... },\n  { connectedChannelId: 2, aiAssistantId: 12, ... },\n  { connectedChannelId: 3, aiAssistantId: 12, ... }\n]\n\n6. Response:\n{\n  currentSubstep: {\n    id: "beezaroAssistants",\n    botMessage: [\n      {\n        type: "text",\n        message: "Assistant removed. Channels were reassigned automatically."\n      },\n      // Updated assistant cards\n    ]\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"draft-finalization-pattern",children:"Draft Finalization Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// When user completes beezaroAssistants:\n\n1. Finalize assistants:\nawait prisma.aiAssistant.updateMany({\n  where: { userId, onboardingDraft: true },\n  data: { onboardingDraft: false }\n})\n\n2. Finalize channel configs:\nawait prisma.channelAiConfig.updateMany({\n  where: {\n    connectedChannelId: { in: userChannelIds },\n    onboardingDraft: true\n  },\n  data: { onboardingDraft: false }\n})\n\n3. State remains unchanged:\n// collected_data.created_assistants stays\n// collected_data.draft_channel_configs stays\n// These are used for reference but no longer "draft"\n\n4. Future edits:\n// If user edits channels again:\n// - Finalized configs are NOT deleted\n// - New draft configs are created alongside\n// - User can switch between draft and finalized setups\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Phase 2, Section B Complete"})}),"\n",(0,i.jsx)(n.p,{children:"This section covered:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Edit context lifecycle and state transitions"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Edit impact chains with complete execution flow"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Edit history tracking and use cases"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Return flow navigation with 4 scenarios + edge cases"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Cleanup patterns for fields, substeps, channels, and assistants"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);